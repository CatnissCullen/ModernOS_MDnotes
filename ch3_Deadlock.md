![e6c33032f53067477f197f9d485fae6](img/e6c33032f53067477f197f9d485fae6.jpg)

# ch3 死锁



## 资源

### 可抢占资源

可直接通过抢占避开死锁（本质：资源分配的重新调整）

****

### 不可抢占资源

不允许抢占，无法通过抢占避开死锁（抢占会引起程序执行故障的副作用，或没有抢占的技术条件）=》重点研究**不可抢占资源**的死锁应对

#### 不可抢占资源的使用步骤

1.  **请求资源**：仅发出请求，不保证请求结果
    -   <u>请求成功</u>，马上可用于运行
    -   <u>请求失败</u>，进入<u>休眠</u>等待可用时被唤醒
2.  **使用资源**：获得资源后正常投入运行
3.  **释放资源**：运行结束后自然/显式释放资源





## 死锁必要条件 × 4

死锁时一定<u>同时发生</u> ——

1.  **互斥**：某资源要么可用要么只被一个进程占用
2.  **占有和等待**：已占有任何资源的进程可<u>直接</u>请求新的资源
3.  **不可抢占**
4.  **环路等待**：进程资源有向图中存在环路

***破坏任意一个条件即可<u>防止</u>死锁发生！！（见死锁预防策略）***





## 死锁应对策略

### 1. 死锁忽略

**鸵鸟算法**：直接假设死锁不会发生，因为虽然已满足4个必要条件，但由于系统运行的随机性，死锁发生的可能性可能很小，忽略也不会有很严重的后果，同时节省了处理死锁的性能和可用性代价

****

### 2. 死锁检测 & 恢复

#### 检测

##### 每种资源只有一个

直接画进程资源有向图，判断是否有环（剪枝算法）

##### 每种资源有多个

利用：

-   **现有资源向量 E**
-   **可用资源向量 A**
-   **当前分配矩阵 C**
-   **请求矩阵 R**（还需要的）

分析是否会发生死锁（见课本p254）

#### 恢复

（看课本p254-p255）

1.  **抢占恢复**
2.   **回滚恢复**
3.  **杀死进程恢复**（破环）

****

### 3. 死锁避免

#### 安全状态和不安全状态

-   **安全状态**：假设所有进程都同时请求对所有资源的最大需求（即题目会给出的请求矩阵），也仍然存在一种调度次序使每个进程都能运行完毕
-   **不安全状态**：即不是**安全状态**的状态，但也不一定会死锁，可能发生运行到一半主动让出资源的情况（非自然释放，但不是抢占！）

#### 银行家算法

看课本p257-p28

****

### 4. 死锁预防

#### 破坏互斥

用假脱机实现用户进程视角的“假共享”

（但可能造成磁盘空间的死锁）

#### 破坏占有等待

-   **方法1**：规定只有占有了最大需求资源才能开始运行
-   **方法2**：允许占有资源时请求新资源，但请求前必须先释放所有已有资源，请求时采用**方法1**

#### 破坏不可抢占

虚拟化资源

#### 破坏环路等待

-   **方法1**：保证每个进程至多只能同时占有1个资源（不同于占有等待！），但有的进程执行的任务必须要用到两个资源，该方法一般不可取
-   **方法2**：给所有资源编号，必须按编号顺序请求资源，这样一定不会出现死锁，资源争夺/冲突时只会发生阻塞
